{
  "name": "WP Slip Verify v2 (OCR Thai) - HMAC + OCR + Postgres Match",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "wp/verify-slip-ocr",
        "responseMode": "responseNode",
        "options": { "rawBody": true }
      },
      "name": "WH WP Verify OCR",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [240, 300],
      "notesInFlow": true,
      "notes": "New webhook for OCR-based verification. Point Woo setting n8n_webhook_url to this path when ready."
    },
    {
      "parameters": {
        "keepOnlySet": false,
        "values": { "string": [ { "name": "secret", "value": "REPLACE_WP_SHARED_SECRET" } ] }
      },
      "name": "Set Secret",
      "type": "n8n-nodes-base.set",
      "typeVersion": 2,
      "position": [520, 300],
      "notesInFlow": true,
      "notes": "WordPress → n8n shared secret (Woo settings: shared_secret)."
    },
    {
      "parameters": {
        "keepOnlySet": false,
        "values": {
          "string": [
            { "name": "tz", "value": "Asia/Bangkok" },
            { "name": "expected_receiver_name", "value": "REPLACE_EXPECTED_RECEIVER_NAME" }
          ],
          "number": [
            { "name": "time_window_sec", "value": 600 },
            { "name": "amount_tol", "value": 0.5 },
            { "name": "name_threshold_strict", "value": 0.85 },
            { "name": "name_threshold_auto", "value": 0.9 }
          ]
        }
      },
      "name": "Set Policy",
      "type": "n8n-nodes-base.set",
      "typeVersion": 2,
      "position": [760, 300],
      "notesInFlow": true,
      "notes": "Policy: 10m window, ±0.50 THB, Thai timezone."
    },
    {
      "parameters": {
        "keepOnlySet": false,
        "values": {
          "string": [
            { "name": "ocr_provider", "value": "ocrspace" },
            { "name": "ocr_api_key", "value": "REPLACE_OCRSPACE_API_KEY" },
            { "name": "ocr_url", "value": "https://api.ocr.space/parse/image" },
            { "name": "ocr_language", "value": "tha" }
          ]
        }
      },
      "name": "Set OCR Config",
      "type": "n8n-nodes-base.set",
      "typeVersion": 2,
      "position": [1000, 300],
      "notesInFlow": true,
      "notes": "Configure OCR provider (OCR.Space). Replace API key."
    },
    {
      "parameters": {
        "keepOnlySet": false,
        "values": {
          "string": [
            { "name": "or_api_key", "value": "REPLACE_OPENROUTER_API_KEY" },
            { "name": "or_model",   "value": "gpt-oss-20b" },
            { "name": "or_title",   "value": "Slip OCR Extractor" },
            { "name": "or_referer", "value": "https://n8n.example.com/" }
          ]
        }
      },
      "name": "Set AI Config",
      "type": "n8n-nodes-base.set",
      "typeVersion": 2,
      "position": [1000, 420],
      "notesInFlow": true,
      "notes": "Configure OpenRouter (free model gpt-oss-20b). Set API key."
    },
    {
      "parameters": {
        "jsCode": "// Verify HMAC: signature = HMAC_SHA256(timestamp + \\n + sha256(body)) using pure JS\nfunction toBytes(str){ if (typeof TextEncoder!== 'undefined') return new TextEncoder().encode(str); var e=[]; for (var i=0;i<str.length;i++){ var c=str.charCodeAt(i); e.push(c & 0xFF);} return new Uint8Array(e);}\nfunction bytesToHex(b){ var s='',h='0123456789abcdef'; for (var i=0;i<b.length;i++){ s+=h[(b[i]>>>4)&15]+h[b[i]&15]; } return s; }\nfunction rotr(x,n){return (x>>>n)|(x<<(32-n));}\nfunction sha256(bytes){ var K=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]; function Ch(x,y,z){return (x & y) ^ (~x & z);} function Maj(x,y,z){return (x & y) ^ (x & z) ^ (y & z);} function S0(x){return rotr(x,2)^rotr(x,13)^rotr(x,22);} function S1(x){return rotr(x,6)^rotr(x,11)^rotr(x,25);} function s0(x){return rotr(x,7)^rotr(x,18)^(x>>>3);} function s1(x){return rotr(x,17)^rotr(x,19)^(x>>>10);} var l=bytes.length; var ml=l*8; var withOne=new Uint8Array(l+1); withOne.set(bytes); withOne[l]=0x80; var padLen=((56-(withOne.length%64))+64)%64; var padded=new Uint8Array(withOne.length+padLen+8); padded.set(withOne); var dv=new DataView(padded.buffer); dv.setUint32(padded.length-8, Math.floor(ml/Math.pow(2,32))); dv.setUint32(padded.length-4, ml>>>0); var H=[1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]; for (var i=0;i<padded.length;i+=64){ var w=new Uint32Array(64); for (var t=0;t<16;t++){ var j=i+t*4; w[t]=(padded[j]<<24)|(padded[j+1]<<16)|(padded[j+2]<<8)|(padded[j+3]); } for (var t=16;t<64;t++){ w[t]=(s1(w[t-2]) + w[t-7] + s0(w[t-15]) + w[t-16])>>>0; } var a=H[0],b=H[1],c=H[2],d=H[3],e=H[4],f=H[5],g=H[6],h=H[7]; for (var t=0;t<64;t++){ var T1=(h + S1(e) + Ch(e,f,g) + K[t] + w[t])>>>0; var T2=(S0(a) + Maj(a,b,c))>>>0; h=g; g=f; f=e; e=(d + T1)>>>0; d=c; c=b; b=a; a=(T1 + T2)>>>0; } H[0]=(H[0]+a)>>>0; H[1]=(H[1]+b)>>>0; H[2]=(H[2]+c)>>>0; H[3]=(H[3]+d)>>>0; H[4]=(H[4]+e)>>>0; H[5]=(H[5]+f)>>>0; H[6]=(H[6]+g)>>>0; H[7]=(H[7]+h)>>>0; } var out=new Uint8Array(32); for (var i2=0;i2<8;i2++){ out[i2*4]=(H[i2]>>>24)&255; out[i2*4+1]=(H[i2]>>>16)&255; out[i2*4+2]=(H[i2]>>>8)&255; out[i2*4+3]=(H[i2])&255; } return out; }\nfunction hmacSha256(keyBytes, msgBytes){ function rpadTo64(key){ if (key.length>64){ key=sha256(key);} var k=new Uint8Array(64); k.set(key); return k;} var k=rpadTo64(keyBytes); var o=new Uint8Array(64), i=new Uint8Array(64); for (var idx=0; idx<64; idx++){ o[idx]=0x5c ^ k[idx]; i[idx]=0x36 ^ k[idx]; } var inner=sha256(new Uint8Array([...i, ...msgBytes])); var h=sha256(new Uint8Array([...o, ...inner])); return h; }\nconst headers=$json.headers||{}; const tsStr=String(headers['X-PromptPay-Timestamp']||headers['x-promptpay-timestamp']||''); const sig=String(headers['X-PromptPay-Signature']||headers['x-promptpay-signature']||''); const body=String($json.rawBody||''); const bodyHashHex=bytesToHex(sha256(toBytes(body))); const signMsg=tsStr + \"\\n\" + bodyHashHex; const key=$item(0).$node['Set Secret'].json.secret || ''; const macHex=bytesToHex(hmacSha256(toBytes(String(key)), toBytes(signMsg))); const skewOk=(function(){ const now=Math.floor(Date.now()/1000); const tsNum=Number(tsStr); return Number.isFinite(tsNum) && Math.abs(now - tsNum) <= 600; })(); const auth_ok = skewOk && sig === macHex; return [{ json: { auth_ok, bodyHashHex } }];"
      },
      "name": "Verify HMAC",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1260, 300]
    },
    {
      "parameters": { "conditions": { "boolean": [ { "value1": "={{$json.auth_ok}}", "operation": "isTrue" } ] } },
      "name": "IF Auth OK?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1500, 300]
    },
    {
      "parameters": { "responseCode": 401, "responseBody": "{\"status\":\"rejected\",\"reason\":\"bad_signature\"}" },
      "name": "Respond 401",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1740, 420]
    },
    {
      "parameters": {
        "jsCode": "// Parse multipart to extract order, session_token, and slip image base64\nfunction getBoundary(ct){ const m=String(ct||'').match(/boundary=([^;]+)$/i); return m?m[1]:''; }\nfunction splitParts(raw, boundary){ const sep='--'+boundary; const arr=raw.split(sep); return arr.filter(p=>p && p.trim()!=='--' && p.indexOf('\\r\\n')!==-1); }\nfunction parseHeaders(part){ const idx=part.indexOf('\\r\\n\\r\\n'); const headStr=idx>=0?part.slice(0,idx):part; const headers={}; headStr.split('\\r\\n').forEach(l=>{ const m=l.match(/^(.*?):\\s*(.*)$/); if(m){ headers[m[1].toLowerCase()]=m[2]; }}); return { headers, bodyStart: idx>=0? idx+4 : part.length }; }\nfunction getName(headerLine){ const m=String(headerLine||'').match(/name=\"([^\"]+)\"/); return m?m[1]:''; }\nfunction getFilename(headerLine){ const m=String(headerLine||'').match(/filename=\"([^\"]*)\"/); return m?m[1]:''; }\nfunction base64FromBinaryString(s){ const bytes = new Uint8Array(s.length); for (let i=0;i<s.length;i++){ bytes[i]=s.charCodeAt(i)&0xFF; } const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='; let out=''; let i=0; while(i<bytes.length){ const b1=bytes[i++]||0, b2=bytes[i++]||0, b3=bytes[i++]||0; const enc1=b1>>2; const enc2=((b1&3)<<4)|(b2>>4); const enc3=((b2&15)<<2)|(b3>>6); const enc4=b3&63; if (isNaN(b2)) { out += chars.charAt(enc1)+chars.charAt(enc2)+'=='; } else if (isNaN(b3)) { out += chars.charAt(enc1)+chars.charAt(enc2)+chars.charAt(enc3)+'='; } else { out += chars.charAt(enc1)+chars.charAt(enc2)+chars.charAt(enc3)+chars.charAt(enc4); } } return out; }\nconst headers=$json.headers||{}; const ct=headers['content-type']||headers['Content-Type']||''; const boundary=getBoundary(ct); const raw=String($json.rawBody||''); const parts=splitParts(raw,boundary); let order={ id:null,total:0,currency:'THB' }, session_token='', slip_b64='', slip_ct='image/jpeg'; for (const part of parts){ const {headers:ph, bodyStart}=parseHeaders(part); const disp = ph['content-disposition']||''; const name=getName(disp); const filename=getFilename(disp); const contentType=ph['content-type']||''; const body=part.slice(bodyStart); const bodyClean = body.replace(/\\r\\n$/, ''); if (name==='order'){ try{ order=JSON.parse(bodyClean||'{}'); }catch(e){} } else if (name==='session_token'){ session_token = bodyClean; } else if (name==='slip_image'){ slip_ct = contentType||'image/jpeg'; const b64 = base64FromBinaryString(bodyClean); slip_b64 = 'data:' + slip_ct + ';base64,' + b64; } } const amount_tol=$item(0).$node['Set Policy'].json.amount_tol; const time_window_sec=$item(0).$node['Set Policy'].json.time_window_sec; return [{ json: { order_id: Number(order.id)||0, order_total: Number(order.total)||0, currency: order.currency||'THB', session_token, slip_base64: slip_b64, slip_content_type: slip_ct, amount_tol, time_window_sec } }];"
      },
      "name": "Parse Multipart",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1740, 180]
    },
    {
      "parameters": {
        "jsCode": "(function(){ const LIMIT=1048576; const b64=String($json.slip_base64||''); function toPureBase64(s){ const t=s.replace(/\\s+/g,''); if(/^data:/i.test(t)){ const i=t.indexOf(','); return i>=0? t.slice(i+1):''; } return t; } const pure=toPureBase64(b64); const len=pure.length; const pad = pure.endsWith('==')?2:(pure.endsWith('=')?1:0); const bytes = Math.floor(len*3/4) - pad; const size_ok = Number.isFinite(bytes) && bytes>0 && bytes <= LIMIT; const out = Object.assign({}, $json, { slip_size_bytes: bytes, size_limit_bytes: LIMIT, size_ok }); return [{ json: out }]; })()"
      },
      "name": "Guard Size <=1MB",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1860, 180],
      "notesInFlow": true,
      "notes": "Rejects if slip_base64 decodes to > 1 MiB."
    },
    {
      "parameters": { "conditions": { "boolean": [ { "value1": "={{$json.size_ok}}", "operation": "isTrue" } ] } },
      "name": "IF Size OK?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [2100, 180]
    },
    {
      "parameters": {
        "responseCode": 413,
        "responseBody": "={{ JSON.stringify({ status: 'rejected', reason: 'file_too_large', limit_bytes: $json.size_limit_bytes, size_bytes: $json.slip_size_bytes }) }}"
      },
      "name": "Respond 413 Too Large",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [2100, 300]
    },
    {
      "parameters": {
        "url": "={{$item(0).$node['Set OCR Config'].json.ocr_url}}",
        "responseFormat": "json",
        "options": { "timeout": 15000, "bodyContentType": "form-urlencoded" },
        "sendBody": true,
        "jsonParameters": false,
        "optionsUi": { "bodyContentType": "form-urlencoded" },
        "queryParametersUi": { "parameter": [] },
        "bodyParametersUi": {
          "parameter": [
            { "name": "apikey", "value": "={{$item(0).$node['Set OCR Config'].json.ocr_api_key}}" },
            { "name": "language", "value": "={{$item(0).$node['Set OCR Config'].json.ocr_language}}" },
            { "name": "isOverlayRequired", "value": "false" },
            { "name": "base64Image", "value": "={{$json.slip_base64}}" }
          ]
        }
      },
      "name": "OCR Request",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [1980, 180],
      "notesInFlow": true,
      "notes": "Sends slip image (base64) to OCR.Space for Thai OCR."
    },
    {
      "parameters": {
        "jsCode": "// Extract parsed text from OCR.Space\nconst res = $json || {}; const parsed = (res.ParsedResults && res.ParsedResults[0] && res.ParsedResults[0].ParsedText) ? String(res.ParsedResults[0].ParsedText) : ''; return [{ json: { ocr_text: parsed, order_total: $item(0).$node['Parse Multipart'].json.order_total, time_window_sec: $item(0).$node['Set Policy'].json.time_window_sec, amount_tol: $item(0).$node['Set Policy'].json.amount_tol } }];"
      },
      "name": "OCR Parse",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2220, 180]
    },
    {
      "parameters": {
        "jsCode": "// Parse Thai slip text: date/time, sender/receiver names, amount (if present)\nfunction parseThaiDateTime(text){ const monthsMap = { 'ม.ค.':0,'ก.พ.':1,'มี.ค.':2,'เม.ย.':3,'พ.ค.':4,'มิ.ย.':5,'ก.ค.':6,'ส.ค.':7,'ก.ย.':8,'ต.ค.':9,'พ.ย.':10,'ธ.ค.':11 }; const re = /(\\d{1,2})\\s+(ม\\.ค\\.|ก\\.พ\\.|มี\\.ค\\.|เม\\.ย\\.|พ\\.ค\\.|มิ\\.ย\\.|ก\\.ค\\.|ส\\.ค\\.|ก\\.ย\\.|ต\\.ค\\.|พ\\.ย\\.|ธ\\.ค\\.)\\s+(\\d{2})\\s+(\\d{1,2}:\\d{2})/; const m = text.replace(/\\s+/g,' ').match(re); if(!m) return null; const d=parseInt(m[1],10); const mon=monthsMap[m[2]]; const yy=parseInt(m[3],10); const hm=m[4].split(':'); const h=parseInt(hm[0],10), mi=parseInt(hm[1],10); const yearCE = 1957 + yy; const dt = new Date(Date.UTC(yearCE, mon, d, h, mi, 0));\n const epoch = Math.floor(dt.getTime()/1000) - ( -7 * 3600 );\n return { epoch }; }\nfunction cleanName(s){ return String(s||'').replace(/[\\s\\u200B]+/g,' ').replace(/\\s+/g,' ').trim(); }\nconst txt = String($json.ocr_text||''); const lines = txt.split(/\\r?\\n/).map(l=>l.trim()).filter(Boolean); let sender='', receiver='', amount=null;\nfor (let i=0;i<lines.length;i++){ const l=lines[i]; if(!sender && /นาย|นาง|น\\.ส\\./.test(l)) { sender = cleanName(l);\n for (let j=i+1;j<Math.min(i+6,lines.length);j++){ if(/นาย|นาง|น\\.ส\\./.test(lines[j])){ receiver = cleanName(lines[j]); break; } } } if (/จำนวน|ยอดเงิน|จำนวนเงิน/.test(l)) { const m2=l.replace(/,/g,'').match(/([0-9]+(?:\\.[0-9]+)?)/); if(m2){ amount=Number(m2[1]); } } } const dt=parseThaiDateTime(txt); const ocr_epoch = dt? dt.epoch : Math.floor(Date.now()/1000); return [{ json: { ocr_epoch, sender_name: sender, receiver_name: receiver, ocr_amount: (Number.isFinite(amount)? amount : null), order_total: $item(0).$node['OCR Parse'].json.order_total, time_window_sec: $item(0).$node['OCR Parse'].json.time_window_sec, amount_tol: $item(0).$node['OCR Parse'].json.amount_tol } }];"
      },
      "name": "Parse Thai Fields",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2460, 180]
    },
    {
      "parameters": {
        "jsCode": "// Check minimal fields from parser\nconst amt = Number($json.ocr_amount);\nconst epoch = Number($json.ocr_epoch);\nconst ok = Number.isFinite(amt) && amt > 0 && Number.isFinite(epoch) && epoch > 0;\nreturn [{ json: Object.assign({}, $json, { fields_ok: ok }) }];"
      },
      "name": "Quality Check",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2700, 120]
    },
    {
      "parameters": { "conditions": { "boolean": [ { "value1": "={{$json.fields_ok}}", "operation": "isTrue" } ] } },
      "name": "IF Fields OK?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [2940, 120]
    },
    {
      "parameters": {
        "url": "https://openrouter.ai/api/v1/chat/completions",
        "responseFormat": "json",
        "options": {
          "timeout": 8000,
          "headers": {
            "Authorization": "=Bearer {{$item(0).$node['Set AI Config'].json.or_api_key}}",
            "HTTP-Referer": "={{$item(0).$node['Set AI Config'].json.or_referer}}",
            "X-Title": "={{$item(0).$node['Set AI Config'].json.or_title}}",
            "Content-Type": "application/json"
          }
        },
        "sendBody": true,
        "jsonParameters": true,
        "options_predefined": {},
        "bodyParametersJson": "={{ JSON.stringify({ model: $item(0).$node['Set AI Config'].json.or_model, response_format: { type: 'json_object' }, temperature: 0, max_tokens: 400, messages: [ { role: 'system', content: 'You are a strict Thai bank slip extractor. Output ONLY JSON with keys: ocr_epoch (integer, epoch seconds, Asia/Bangkok, convert Buddhist year to Gregorian), sender_name (string), receiver_name (string), ocr_amount (number). If missing, set null.' }, { role: 'user', content: $item(0).$node['OCR Parse'].json.ocr_text } ] }) }}"
      },
      "name": "AI Extract (OpenRouter)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [3180, 300],
      "notesInFlow": true,
      "notes": "Extract slip fields via OpenRouter (gpt-oss-20b)."
    },
    {
      "parameters": {
        "jsCode": "// Parse AI extract JSON and map fields\nreturn items.map(item=>{ try{ const content = item.json.choices?.[0]?.message?.content || '{}'; const obj = JSON.parse(content); const out = { ocr_epoch: Number(obj.ocr_epoch)||Math.floor(Date.now()/1000), sender_name: String(obj.sender_name||''), receiver_name: String(obj.receiver_name||''), ocr_amount: (Number(obj.ocr_amount)||0), order_total: $item(0).$node['Parse Multipart'].json.order_total, time_window_sec: $item(0).$node['Set Policy'].json.time_window_sec, amount_tol: $item(0).$node['Set Policy'].json.amount_tol }; item.json = out; } catch(e){ item.json = Object.assign({}, item.json, { ai_extract_error: String(e) }); } return item; });"
      },
      "name": "AI Extract Parse",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3420, 300]
    },
    {
      "parameters": {
        "url": "https://openrouter.ai/api/v1/chat/completions",
        "responseFormat": "json",
        "options": {
          "timeout": 6000,
          "headers": {
            "Authorization": "=Bearer {{$item(0).$node['Set AI Config'].json.or_api_key}}",
            "HTTP-Referer": "={{$item(0).$node['Set AI Config'].json.or_referer}}",
            "X-Title": "={{$item(0).$node['Set AI Config'].json.or_title}}",
            "Content-Type": "application/json"
          }
        },
        "sendBody": true,
        "jsonParameters": true,
        "options_predefined": {},
        "bodyParametersJson": "={{ JSON.stringify({ model: $item(0).$node['Set AI Config'].json.or_model, response_format: { type: 'json_object' }, temperature: 0, max_tokens: 80, messages: [ { role: 'system', content: 'Return ONLY JSON with a single key name_score (number between 0 and 1). Score similarity between expected payee name and observed receiver name from a Thai bank slip. Be robust to spacing/diacritics/minor OCR errors. No explanations.' }, { role: 'user', content: 'Expected: ' + $item(0).$node['Set Policy'].json.expected_receiver_name + '\nObserved: ' + $json.receiver_name } ] }) }}"
      },
      "name": "AI Name Score (OpenRouter)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [3180, 120],
      "notesInFlow": true,
      "notes": "Compute name similarity score 0..1."
    },
    {
      "parameters": {
        "jsCode": "// Parse name_score JSON and keep pass-through fields\nreturn items.map(item=>{ try{ const content = item.json.choices?.[0]?.message?.content || '{}'; const obj = JSON.parse(content); const score = Number(obj.name_score); item.json = Object.assign({}, $json, { name_score: (Number.isFinite(score)? score : 0) }); } catch(e){ item.json = Object.assign({}, $json, { name_score: 0, ai_name_error: String(e) }); } return item; });"
      },
      "name": "AI Name Score Parse",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3420, 120]
    },
    {
      "parameters": {
        "keepOnlySet": false,
        "values": { "boolean": [ { "name": "name_ok", "value": "={{ Number($json.name_score) >= $item(0).$node['Set Policy'].json.name_threshold_strict }}" } ] }
      },
      "name": "Set Name OK",
      "type": "n8n-nodes-base.set",
      "typeVersion": 2,
      "position": [3660, 120]
    },
    {
      "parameters": { "conditions": { "boolean": [ { "value1": "={{$json.name_ok}}", "operation": "isTrue" } ] } },
      "name": "IF Name OK?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [3900, 120]
    },
    {
      "parameters": {
        "responseCode": 200,
        "responseBody": "{\"status\":\"rejected\",\"reason\":\"name_mismatch\",\"message\":\"ชื่อผู้รับเงินบนสลิปไม่ตรงกับชื่อร้านค้า\"}"
      },
      "name": "Respond Name Mismatch",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [4140, 240]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{`WITH params AS (\n  SELECT to_timestamp(${$json.ocr_epoch}) AS center, ${$json.order_total}::numeric AS want_amt, ${$json.amount_tol}::numeric AS tol, ${$item(0).$node['Set Policy'].json.time_window_sec}::int AS win\n), cte AS (\n  SELECT message_id, amount, txn_time, created_at\n  FROM payments p, params\n  WHERE used = false\n    AND p.created_at BETWEEN (params.center - (params.win || ' seconds')::interval) AND (params.center + (params.win || ' seconds')::interval)\n    AND p.amount BETWEEN (params.want_amt - params.tol) AND (params.want_amt + params.tol)\n  ORDER BY created_at DESC\n  LIMIT 1\n)\nUPDATE payments p\nSET used = true\nFROM cte\nWHERE p.message_id = cte.message_id\nRETURNING cte.message_id, cte.amount;`}}"
      },
      "name": "PG Match+Consume (OCR)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [2700, 180],
      "notesInFlow": true,
      "notes": "Matches near OCR time within tolerance and marks used. Set Postgres credentials."
    },
    {
      "parameters": { "conditions": { "number": [ { "value1": "={{ $json[\"_rows\"] ? $json._rows.length : 0 }}", "operation": "larger" } ] } },
      "name": "IF Found?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [2940, 180]
    },
    {
      "parameters": {
        "responseCode": 200,
        "responseBody": "={{ (()=>{ const row = ($json._rows && $json._rows[0]) ? $json._rows[0] : null; const ref = row ? row.message_id : ''; const amt = row ? Number(row.amount) : 0; return JSON.stringify({ status:'approved', reference_id: ref, approved_amount: amt }); })() }}"
      },
      "name": "Respond Approved",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [3180, 120]
    },
    {
      "parameters": {
        "responseCode": 200,
        "responseBody": "{\"status\":\"rejected\",\"reason\":\"no_match\",\"message\":\"No payment matched near OCR time.\"}"
      },
      "name": "Respond Rejected",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [3180, 240]
    }
  ],
  "connections": {
    "WH WP Verify OCR": { "main": [[ { "node": "Set Secret", "type": "main", "index": 0 } ]] },
    "Set Secret": { "main": [[ { "node": "Set Policy", "type": "main", "index": 0 } ]] },
    "Set Policy": { "main": [[ { "node": "Set OCR Config", "type": "main", "index": 0 } ]] },
    "Set OCR Config": { "main": [[ { "node": "Set AI Config", "type": "main", "index": 0 } ]] },
    "Set AI Config": { "main": [[ { "node": "Verify HMAC", "type": "main", "index": 0 } ]] },
    "Verify HMAC": { "main": [[ { "node": "IF Auth OK?", "type": "main", "index": 0 } ]] },
    "IF Auth OK?": { "main": [ [ { "node": "Parse Multipart", "type": "main", "index": 0 } ], [ { "node": "Respond 401", "type": "main", "index": 0 } ] ] },
    "Parse Multipart": { "main": [[ { "node": "Guard Size <=1MB", "type": "main", "index": 0 } ]] },
    "Guard Size <=1MB": { "main": [[ { "node": "IF Size OK?", "type": "main", "index": 0 } ]] },
    "IF Size OK?": { "main": [ [ { "node": "OCR Request", "type": "main", "index": 0 } ], [ { "node": "Respond 413 Too Large", "type": "main", "index": 0 } ] ] },
    "OCR Request": { "main": [[ { "node": "OCR Parse", "type": "main", "index": 0 } ]] },
    "OCR Parse": { "main": [[ { "node": "Parse Thai Fields", "type": "main", "index": 0 } ]] },
    "Parse Thai Fields": { "main": [[ { "node": "Quality Check", "type": "main", "index": 0 } ]] },
    "Quality Check": { "main": [[ { "node": "IF Fields OK?", "type": "main", "index": 0 } ]] },
    "IF Fields OK?": { "main": [ [ { "node": "AI Name Score (OpenRouter)", "type": "main", "index": 0 } ], [ { "node": "AI Extract (OpenRouter)", "type": "main", "index": 0 } ] ] },
    "AI Extract (OpenRouter)": { "main": [[ { "node": "AI Extract Parse", "type": "main", "index": 0 } ]] },
    "AI Extract Parse": { "main": [[ { "node": "AI Name Score (OpenRouter)", "type": "main", "index": 0 } ]] },
    "AI Name Score (OpenRouter)": { "main": [[ { "node": "AI Name Score Parse", "type": "main", "index": 0 } ]] },
    "AI Name Score Parse": { "main": [[ { "node": "Set Name OK", "type": "main", "index": 0 } ]] },
    "Set Name OK": { "main": [[ { "node": "IF Name OK?", "type": "main", "index": 0 } ]] },
    "IF Name OK?": { "main": [ [ { "node": "PG Match+Consume (OCR)", "type": "main", "index": 0 } ], [ { "node": "Respond Name Mismatch", "type": "main", "index": 0 } ] ] },
    "PG Match+Consume (OCR)": { "main": [[ { "node": "IF Found?", "type": "main", "index": 0 } ]] },
    "IF Found?": { "main": [ [ { "node": "Respond Approved", "type": "main", "index": 0 } ], [ { "node": "Respond Rejected", "type": "main", "index": 0 } ] ] }
  }
,
  "active": false
}
