{
  "name": "WP Slip Verify v1 - HMAC + Postgres Match",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "wp/verify-slip",
        "responseMode": "responseNode",
        "options": { "rawBody": true }
      },
      "name": "WH WP Verify",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [240, 300]
    },
    {
      "parameters": {
        "keepOnlySet": false,
        "values": { "string": [ { "name": "secret", "value": "REPLACE_WP_SHARED_SECRET" } ] }
      },
      "name": "Set Secret",
      "type": "n8n-nodes-base.set",
      "typeVersion": 2,
      "position": [520, 300],
      "notesInFlow": true,
      "notes": "WordPress → n8n shared secret (Woo settings: shared_secret)."
    },
    {
      "parameters": {
        "keepOnlySet": false,
        "values": {
          "number": [
            { "name": "time_window_sec", "value": 600 },
            { "name": "amount_tol", "value": 0.5 }
          ]
        }
      },
      "name": "Set Policy",
      "type": "n8n-nodes-base.set",
      "typeVersion": 2,
      "position": [760, 300],
      "notesInFlow": true,
      "notes": "Approval policy: 10m window, ±0.50 THB tolerance."
    },
    {
      "parameters": {
        "jsCode": "// Verify HMAC like plugin: signature = HMAC_SHA256(timestamp + \n + sha256(body))\nfunction toBytes(str){ if (typeof TextEncoder !== 'undefined') return new TextEncoder().encode(str); var e=[]; for (var i=0;i<str.length;i++){ var c=str.charCodeAt(i); if (c<128){e.push(c);} else if (c<2048){ e.push((c>>6)|192,(c&63)|128);} else if (c<55296||c>=57344){ e.push((c>>12)|224,((c>>6)&63)|128,(c&63)|128);} else { i++; c=65536+(((c&1023)<<10)|(str.charCodeAt(i)&1023)); e.push((c>>18)|240,((c>>12)&63)|128,((c>>6)&63)|128,(c&63)|128);} } return new Uint8Array(e); }\nfunction bytesToHex(b){ var s='',h='0123456789abcdef'; for (var i=0;i<b.length;i++){ s+=h[(b[i]>>>4)&15]+h[b[i]&15]; } return s; }\nfunction sha256(bytes){ var K=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]; function rotr(x,n){return (x>>>n)|(x<<(32-n));} function ch(x,y,z){return (x&y)^(~x&z);} function maj(x,y,z){return (x&y)^(x&z)^(y&z);} function S0(x){return rotr(x,2)^rotr(x,13)^rotr(x,22);} function S1(x){return rotr(x,6)^rotr(x,11)^rotr(x,25);} function s0(x){return rotr(x,7)^rotr(x,18)^(x>>>3);} function s1(x){return rotr(x,17)^rotr(x,19)^(x>>>10);} var l=bytes.length; var ml=l*8; var withOne=new Uint8Array(l+1); withOne.set(bytes); withOne[l]=0x80; var k=((56-(withOne.length%64))+64)%64; var padded=new Uint8Array(withOne.length+k+8); padded.set(withOne); for (var i=0;i<8;i++){ padded[padded.length-1-i]=(ml>>> (i*8)) & 255; } var H=[1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]; var w=new Uint32Array(64); for (var i2=0;i2<padded.length;i2+=64){ for (var t=0;t<16;t++){ var j=i2+t*4; w[t]= (padded[j]<<24)|(padded[j+1]<<16)|(padded[j+2]<<8)|(padded[j+3]); } for (var t2=16;t2<64;t2++){ w[t2]=(s1(w[t2-2])+w[t2-7]+s0(w[t2-15])+w[t2-16])>>>0; } var a=H[0],b=H[1],c=H[2],d=H[3],e=H[4],f=H[5],g=H[6],h=H[7]; for (var t3=0;t3<64;t3++){ var T1=(h+S1(e)+ch(e,f,g)+K[t3]+w[t3])>>>0; var T2=(S0(a)+maj(a,b,c))>>>0; h=g; g=f; f=e; e=(d+T1)>>>0; d=c; c=b; b=a; a=(T1+T2)>>>0; } H[0]=(H[0]+a)>>>0; H[1]=(H[1]+b)>>>0; H[2]=(H[2]+c)>>>0; H[3]=(H[3]+d)>>>0; H[4]=(H[4]+e)>>>0; H[5]=(H[5]+f)>>>0; H[6]=(H[6]+g)>>>0; H[7]=(H[7]+h)>>>0; } var out=new Uint8Array(32); for (var i3=0;i3<8;i3++){ out[i3*4]=(H[i3]>>>24)&255; out[i3*4+1]=(H[i3]>>>16)&255; out[i3*4+2]=(H[i3]>>>8)&255; out[i3*4+3]=H[i3]&255; } return out; }\nfunction hmacSha256(keyBytes, msgBytes){ function ipad(n){var a=new Uint8Array(n.length); for(var i=0;i<n.length;i++){a[i]=n[i]^0x36;} return a;} function opad(n){var a=new Uint8Array(n.length); for(var i=0;i<n.length;i++){a[i]=n[i]^0x5c;} return a;} var blockSize=64; if (keyBytes.length>blockSize){ keyBytes=sha256(keyBytes);} if (keyBytes.length<blockSize){ var k=new Uint8Array(blockSize); k.set(keyBytes); keyBytes=k; } var i=ipad(keyBytes), o=opad(keyBytes); var inner=new Uint8Array(i.length+msgBytes.length); inner.set(i); inner.set(msgBytes,i.length); var innerHash=sha256(inner); var outer=new Uint8Array(o.length+innerHash.length); outer.set(o); outer.set(innerHash,o.length); return sha256(outer); }\nconst headers=$json.headers||{}; const lower=Object.fromEntries(Object.entries(headers).map(([k,v])=>[String(k).toLowerCase(),v])); const ts=String(lower['x-promptpay-timestamp']||''); const sig=String(lower['x-promptpay-signature']||''); const secret=$item(0).$node['Set Secret'].json.secret||''; const raw=String($json.rawBody||''); const bodyHash=bytesToHex(sha256(toBytes(raw))); const msg=toBytes(ts+'\n'+bodyHash); const mac=bytesToHex(hmacSha256(toBytes(secret), msg)); const ok = mac===sig && Math.abs((Date.now()/1000)-Number(ts))<=600; return [{json:{auth_ok:ok, headers, rawBody:$json.rawBody}}];"
      },
      "name": "Verify HMAC",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1020, 300]
    },
    {
      "parameters": { "conditions": { "boolean": [ { "value1": "={{$json.auth_ok}}", "operation": "isTrue" } ] } },
      "name": "IF Auth OK?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1260, 300]
    },
    {
      "parameters": { "responseCode": 401, "responseBody": "{\"status\":\"rejected\",\"reason\":\"bad_signature\"}" },
      "name": "Respond 401",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1500, 420]
    },
    {
      "parameters": {
        "jsCode": "// Parse multipart for fields: order (JSON), session_token (string).\nfunction getBoundary(ct){ const m=String(ct||'').match(/boundary=([^;]+)$/i); return m?m[1]:''; }\nfunction parseField(raw, boundary, name){ const parts=raw.split('--'+boundary); for (const p of parts){ if (p.indexOf('name=\"'+name+'\"')!==-1){ const idx=p.indexOf('\r\n\r\n'); if (idx!==-1){ return p.slice(idx+4).replace(/\r\n$/, ''); } } } return ''; }\nconst headers=$json.headers||{}; const ct=headers['content-type']||headers['Content-Type']||''; const boundary=getBoundary(ct); const raw=String($json.rawBody||''); const orderStr=parseField(raw,boundary,'order'); const session_token=parseField(raw,boundary,'session_token'); let order={ id:null, total:0, currency:'THB' }; try { order=JSON.parse(orderStr||'{}'); } catch(e){} const amount_tol=$item(0).$node['Set Policy'].json.amount_tol; const time_window_sec=$item(0).$node['Set Policy'].json.time_window_sec; return [{ json: { order_id: Number(order.id)||0, order_total: Number(order.total)||0, currency: order.currency||'THB', session_token, amount_tol, time_window_sec } }];"
      },
      "name": "Parse Multipart",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1500, 180]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{`WITH cte AS (\n  SELECT message_id, amount, txn_time, created_at\n  FROM payments\n  WHERE used = false\n    AND created_at >= now() - interval '${$json.time_window_sec} seconds'\n    AND amount BETWEEN ${$json.order_total} - ${$json.amount_tol} AND ${$json.order_total} + ${$json.amount_tol}\n  ORDER BY created_at DESC\n  LIMIT 1\n)\nUPDATE payments p\nSET used = true\nFROM cte\nWHERE p.message_id = cte.message_id\nRETURNING cte.message_id, cte.amount;`}}"
      },
      "name": "PG Match+Consume",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [1740, 180],
      "notesInFlow": true,
      "notes": "Set Postgres credentials. Matches a recent unused payment within tolerance and marks it used."
    },
    {
      "parameters": { "conditions": { "number": [ { "value1": "={{ $json[\"_rows\"] ? $json._rows.length : 0 }}", "operation": "larger" } ] } },
      "name": "IF Found?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1980, 180]
    },
    {
      "parameters": {
        "responseCode": 200,
        "responseBody": "={{ (()=>{ const row = ($json._rows && $json._rows[0]) ? $json._rows[0] : null; const ref = row ? row.message_id : ''; const amt = row ? Number(row.amount) : 0; return JSON.stringify({ status:'approved', reference_id: ref, approved_amount: amt }); })() }}"
      },
      "name": "Respond Approved",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [2220, 120]
    },
    {
      "parameters": {
        "responseCode": 200,
        "responseBody": "{\"status\":\"rejected\",\"reason\":\"no_match\",\"message\":\"No recent payment matched.\"}"
      },
      "name": "Respond Rejected",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [2220, 240]
    }
  ],
  "connections": {
    "WH WP Verify": { "main": [[ { "node": "Set Secret", "type": "main", "index": 0 } ]] },
    "Set Secret": { "main": [[ { "node": "Set Policy", "type": "main", "index": 0 } ]] },
    "Set Policy": { "main": [[ { "node": "Verify HMAC", "type": "main", "index": 0 } ]] },
    "Verify HMAC": { "main": [[ { "node": "IF Auth OK?", "type": "main", "index": 0 } ]] },
    "IF Auth OK?": { "main": [ [ { "node": "Parse Multipart", "type": "main", "index": 0 } ], [ { "node": "Respond 401", "type": "main", "index": 0 } ] ] },
    "Parse Multipart": { "main": [[ { "node": "PG Match+Consume", "type": "main", "index": 0 } ]] },
    "PG Match+Consume": { "main": [[ { "node": "IF Found?", "type": "main", "index": 0 } ]] },
    "IF Found?": { "main": [ [ { "node": "Respond Approved", "type": "main", "index": 0 } ], [ { "node": "Respond Rejected", "type": "main", "index": 0 } ] ] }
  },
  "active": true
}
