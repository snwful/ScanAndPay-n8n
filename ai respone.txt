

เยี่ยมเลย เป้าหมาย “ไร้สลิป, ฟรีค่าธรรมเนียม, มืออาชีพ” ทำได้ครับ ต่อไปนี้คือภาพรวมสถาปัตยกรรม/การทำงานที่แนะนำ โดยยึดไฟล์ในโปรเจ็กต์คุณตอนนี้

# Desired UX (จากมุมมองลูกค้า)
- เลือกวิธีชำระ PromptPay → เห็น QR พร้อมยอดเงิน (เพิ่มเศษสตางค์ 2 หลักท้ายเป็นตัวแยกคำสั่งซื้อ)
- ไม่ต้องอัปโหลดสลิป
- จ่ายเสร็จ ระบบตรวจจับการโอนอัตโนมัติ → ออเดอร์ “ชำระแล้ว” แบบไร้รอยต่อ

# Components และไฟล์ที่เกี่ยวข้อง
- __WordPress plugin__:
  - [scanandpay-n8n.php](cci:7://file:///Users/BANKOFFIT/Documents/Github%20Clone/ScanAndPay-n8n/scanandpay-n8n.php:0:0-0:0) (main)
  - เพิ่มคลาส REST proxy/HMAC และ gateway ต่อไปใน `includes/` เช่น:
    - `includes/class-san8n-api.php` (WP REST proxy → เซ็น HMAC แล้ว forward ไป n8n)
    - [includes/class-san8n-gateway.php](cci:7://file:///Users/BANKOFFIT/Documents/Github%20Clone/ScanAndPay-n8n/includes/class-san8n-gateway.php:0:0-0:0) (WooCommerce gateway: แสดง QR, เริ่ม poll)
- __n8n workflows__:
  - `WP QR Generate debug.fixed.json` สร้าง EMV PromptPay + TTL + unique cents
  - `Tasker Ingest.v5.3.ai-openrouter.v2.json` รับแจ้งเตือนจากมือถือ → AI Guardrail → จับคู่ session
  - `WP Verify Slip.v2.ocr.json` ตัวเลือกสำรอง (ปิด/เก็บไว้ใช้ฉุกเฉิน)
  - ใหม่ที่จะเพิ่ม: `/order/status` และ callback → WP

# End-to-End Flow
1) __Checkout (WP)__
- คิดยอด base แล้วคำนวณ “เศษสตางค์เฉพาะ” ด้วย `use_unique_cents=true, unique_cents_mod=10` ใน `WP QR Generate debug.fixed.json`
- WP เรียก REST proxy: `POST /wp-json/san8n/v1/qr/generate` พร้อม `order_id, amount, currency, session_token`
- Proxy สร้าง raw JSON, สร้าง HMAC ตามสูตรเดียวกับ Postman pre-script แล้วส่งไป n8n webhook ของ `WP QR Generate` (แทนที่การใช้ Postman)

2) __Generate QR (n8n: `WP QR Generate debug.fixed.json`)__
- `Verify HMAC` (pure-JS + guard) ตรวจ header และ raw body
- `Build Session` สร้างข้อมูล session: `order_id, session_token, amount_variant, expires_epoch` และ EMV payload
- บันทึก session ลง store (แนะนำ Postgres) พร้อม `TTL, used=false` และ index ที่จำเป็น
- ตอบกลับไป WP: `emv, amount_to_pay, currency, expires_epoch`

3) __Show QR + Poll (WP)__ 
- ปลั๊กอินแสดง QR จาก `emv` และเริ่ม poll สถานะทุก X วินาที ที่ WP proxy: `GET /wp-json/san8n/v1/order/status?order_id=&session_token=` (WP จะ proxy ไป n8n)
- สถานะที่คาด: `pending | paid | expired | cancelled`

4) __Slipless Verification (Tasker)__
- มือถือ Android มี Tasker อ่าน Notification ของแอปธนาคาร → POST ไป `tasker/ingest` ของ `Tasker Ingest.v5.3.ai-openrouter.v2.json` พร้อม HMAC
- Workflow นี้:
  - `Verify HMAC` (สูตรเดียวกับ QR Generate)
  - Parser + __AI Guardrail__ map เป็นฟิลด์: `amount, datetime_epoch, account_name/...`
  - __Match Engine__:
    - หา session ที่ `used=false` และอยู่ในหน้าต่างเวลา 10 นาที
    - ถ้าเปิด unique cents ให้ match แบบ __exact amount__ กับ `amount_variant`
    - ถ้าจำเป็นค่อย fallback tolerance ±0.50 THB ร่วมกับคะแนนชื่อ/เวลา
  - เมื่อ match สำเร็จ: mark `used=true, paid_at_epoch`, เก็บ evidence hash/notification hash สำหรับ anti-reuse
  - __Callback WP__: POST ไป `wp-json/san8n/v1/order/paid` เพื่อ mark order เป็น “processing/paid”

5) __Order becomes paid__
- WP หยุด poll ทันทีเมื่อสถานะเป็น `paid` หรือหมดเวลาเป็น `expired`

6) __Fallback (เลือกใช้)__
- `WP Verify Slip.v2.ocr.json` เปิดในกรณีมีปัญหา Tasker/IMAP ชั่วคราว

# Data Model (Session Store)
- Table: `payment_sessions`
  - Keys: `session_token (PK)`, `order_id (index)`, `amount_base`, `amount_variant`, `expires_epoch`, `used (bool)`, `created_at_epoch`
  - Evidence: `source=tasker|imap`, `evidence_hash`, `payer_name`, `matched_at_epoch`
- กติกา
  - `TTL`: 10 นาที
  - `used=true` หลัง match สำเร็จ (anti-reuse)
  - Unique index: `(order_id, used=false)` เพื่อกันเปิดหลาย session ซ้อน

# Security & Anti-abuse
- __HMAC everywhere__: WP proxy → n8n (เหมือน Postman pre), Tasker → n8n
- __Trim secret__, เก็บเป็น Base64 ใน WP option และ n8n env
- __Rotation__: รองรับ rotate secret แบบคู่ (old/new) ช่วงเปลี่ยนผ่าน
- __Guard__: ป้องกัน payload > 2MB
- __Idempotency__: ใช้ `session_token` และ `order_id` เป็น idempotency keys

# Observability
- Log รายการสำคัญ: verify pass/fail, match result, callback result
- Dead-letter: เก็บ notification ที่ parse ไม่ได้/ไม่ match ไว้ตรวจสอบ
- Metrics: success rate, time-to-match

# จุดเชื่อมกับไฟล์ในโปรเจ็กต์
- `WP QR Generate debug.fixed.json`
  - มี `Verify HMAC` แบบ pure-JS แล้ว และการ parse amount แข็งแรง
  - แนะนำเพิ่ม Node เขียน `payment_sessions` (Postgres) และคืน `session_token, amount_variant`
- `Tasker Ingest.v5.3.ai-openrouter.v2.json`
  - คง `WH Tasker` + `Set Secret`
  - เพิ่ม `Verify HMAC` แบบเดียวกับ QR Generate
  - Parser + AI Guardrail → Match Engine → Postgres update `used=true` → `HTTP Request` callback ไป WP
- `WP Verify Slip.v2.ocr.json`
  - เก็บเป็น fallback
- [scanandpay-n8n.php](cci:7://file:///Users/BANKOFFIT/Documents/Github%20Clone/ScanAndPay-n8n/scanandpay-n8n.php:0:0-0:0)
  - สมัคร REST routes:
    - `POST /wp-json/san8n/v1/qr/generate` → เซ็น HMAC แล้ว forward
    - `GET /wp-json/san8n/v1/order/status` → proxy ไป n8n
    - `POST /wp-json/san8n/v1/order/paid` → endpoint ให้ n8n callback
  - WooCommerce gateway แสดง QR และเริ่ม poll

# Matching Logic ที่แนะนำ
- __โหมดหลัก__: unique cents on → require exact amount match กับ `amount_variant` ภายใน TTL
- __โหมด fallback__: หากธนาคารปัดเศษหรือข้อมูลไม่ครบ ใช้ window เวลา + tolerance ±0.50 THB + ชื่อผู้โอน + confidence จาก AI
- ป้องกัน reuse: notification hash ใด ๆ ใช้ match ได้ครั้งเดียว

# Next Actions (สั้น ๆ)
- __WP REST proxy__ สำหรับ `/qr/generate`, `/order/status`, `/order/paid`
- __n8n session store (Postgres)__ + nodes สำหรับ upsert/find/update
- __เติม Verify HMAC + Match Engine__ ใน `Tasker Ingest.v5.3...`
- __Polling UI__ ใน WP (แสดงสถานะ paid/expired)

ถ้าคุณ OK ผมจะเริ่มที่ “WP REST proxy + n8n /order/status” ก่อน เพื่อให้ปลั๊กอินเรียกใช้งานจริงแทน Postman แล้วค่อยเติมฝั่ง Tasker Match Engine ต่อครับ

สรุปสถานะ: โครงสร้างพร้อมต่อยอด slipless แล้ว เหลือต่อชิ้นส่วน proxy/status/store/match/callback ให้ครบวงจร